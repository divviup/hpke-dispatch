<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="hpke"><title>hpke - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="hpke" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../hpke/index.html">hpke</a><span class="version">0.13.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#hpke" title="hpke">hpke</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>hpke</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/hpke/lib.rs.html#1-227">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="hpke"><a class="doc-anchor" href="#hpke">§</a>hpke</h2>
<p><strong>WARNING:</strong> This code has not been audited. Use at your own discretion.</p>
<p>This is a pure Rust implementation of the
<a href="https://datatracker.ietf.org/doc/rfc9180/">HPKE</a> hybrid encryption scheme (RFC 9180). The
purpose of hybrid encryption is to use allow someone to send secure messages to an entity whose
public key they know. Here’s an example of Alice and Bob, where Alice knows Bob’s public key:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// These types define the ciphersuite Alice and Bob will be using
</span><span class="kw">type </span>Kem = X25519HkdfSha256;
<span class="kw">type </span>Aead = ChaCha20Poly1305;
<span class="kw">type </span>Kdf = HkdfSha384;

<span class="kw">let </span><span class="kw-2">mut </span>csprng = StdRng::from_os_rng();

<span class="comment">// This is a description string for the session. Both Alice and Bob need to know this value.
// It's not secret.
</span><span class="kw">let </span>info_str = <span class="string">b"Alice and Bob's weekly chat"</span>;

<span class="comment">// Alice initiates a session with Bob. OpModeS::Base means that Alice is not authenticating
// herself at all. If she had a public key herself, or a pre-shared secret that Bob also
// knew, she'd be able to authenticate herself. See the OpModeS and OpModeR types for more
// detail.
</span><span class="kw">let </span>(encapsulated_key, <span class="kw-2">mut </span>encryption_context) =
    hpke::setup_sender::&lt;Aead, Kdf, Kem, <span class="kw">_</span>&gt;(<span class="kw-2">&amp;</span>OpModeS::Base, <span class="kw-2">&amp;</span>bob_pk, info_str, <span class="kw-2">&amp;mut </span>csprng)
        .expect(<span class="string">"invalid server pubkey!"</span>);

<span class="comment">// Alice encrypts a message to Bob. `aad` is authenticated associated data that is not
// encrypted.
</span><span class="kw">let </span>msg = <span class="string">b"fronthand or backhand?"</span>;
<span class="kw">let </span>aad = <span class="string">b"a gentleman's game"</span>;
<span class="comment">// To seal without allocating:
//     let auth_tag = encryption_context.seal_in_place_detached(&amp;mut msg, aad)?;
// To seal with allocating:
</span><span class="kw">let </span>ciphertext = encryption_context.seal(msg, aad).expect(<span class="string">"encryption failed!"</span>);

<span class="comment">// ~~~
// Alice sends the encapsulated key, message ciphertext, AAD, and auth tag to Bob over the
// internet. Alice doesn't care if it's an insecure connection, because only Bob can read
// her ciphertext.
// ~~~

// Somewhere far away, Bob receives the data and makes a decryption session
</span><span class="kw">let </span><span class="kw-2">mut </span>decryption_context =
    hpke::setup_receiver::&lt;Aead, Kdf, Kem&gt;(
        <span class="kw-2">&amp;</span>OpModeR::Base,
        <span class="kw-2">&amp;</span>bob_sk,
        <span class="kw-2">&amp;</span>encapsulated_key,
        info_str,
    ).expect(<span class="string">"failed to set up receiver!"</span>);
<span class="comment">// To open without allocating:
//     decryption_context.open_in_place_detached(&amp;mut ciphertext, aad, &amp;auth_tag)
// To open with allocating:
</span><span class="kw">let </span>plaintext = decryption_context.open(<span class="kw-2">&amp;</span>ciphertext, aad).expect(<span class="string">"invalid ciphertext!"</span>);

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>plaintext, <span class="string">b"fronthand or backhand?"</span>);</code></pre></div>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.generic_array"><code>pub use <a class="mod" href="../generic_array/index.html" title="mod generic_array">generic_array</a>;</code><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dt id="reexport.rand_core"><code>pub use <a class="mod" href="../rand_core/index.html" title="mod rand_core">rand_core</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="aead/index.html" title="mod hpke::aead">aead</a></dt><dd>Traits and structs for authenticated encryption schemes</dd><dt><a class="mod" href="kdf/index.html" title="mod hpke::kdf">kdf</a></dt><dd>Traits and structs for key derivation functions</dd><dt><a class="mod" href="kem/index.html" title="mod hpke::kem">kem</a></dt><dd>Traits and structs for key encapsulation mechanisms</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.PskBundle.html" title="struct hpke::PskBundle">PskBundle</a></dt><dd>Contains preshared key bytes and an identifier. This is intended to go inside an <code>OpModeR</code> or
<code>OpModeS</code> struct.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.HpkeError.html" title="enum hpke::HpkeError">Hpke<wbr>Error</a></dt><dd>Describes things that can go wrong in the HPKE protocol</dd><dt><a class="enum" href="enum.OpModeR.html" title="enum hpke::OpModeR">OpModeR</a></dt><dd>The operation mode of the HPKE session (receiver’s view). This is how the sender authenticates
their identity to the receiver. This authentication information can include a preshared key,
the identity key of the sender, both, or neither. <code>Base</code> is the only mode that does not provide
any kind of sender identity authentication.</dd><dt><a class="enum" href="enum.OpModeS.html" title="enum hpke::OpModeS">OpModeS</a></dt><dd>The operation mode of the HPKE session (sender’s view). This is how the sender authenticates
their identity to the receiver. This authentication information can include a preshared key,
the identity key of the sender, both, or neither. <code>Base</code> is the only mode that does not provide
any kind of sender identity authentication.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Deserializable.html" title="trait hpke::Deserializable">Deserializable</a></dt><dd>Implemented by types that can be deserialized from byte representation</dd><dt><a class="trait" href="trait.Kem.html" title="trait hpke::Kem">Kem</a></dt><dd>Represents authenticated encryption functionality</dd><dt><a class="trait" href="trait.Serializable.html" title="trait hpke::Serializable">Serializable</a></dt><dd>Implemented by types that have a fixed-length byte representation</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.setup_receiver.html" title="fn hpke::setup_receiver">setup_<wbr>receiver</a></dt><dd>Initiates a decryption context given a private key <code>sk_recip</code> and an encapsulated key which
was encapsulated to <code>sk_recip</code>’s corresponding public key</dd><dt><a class="fn" href="fn.setup_sender.html" title="fn hpke::setup_sender">setup_<wbr>sender</a></dt><dd>Initiates an encryption context to the given recipient public key</dd><dt><a class="fn" href="fn.single_shot_open.html" title="fn hpke::single_shot_open">single_<wbr>shot_<wbr>open</a></dt><dd>Does a <code>setup_receiver</code> and <code>AeadCtxR::open</code> in one shot. That is, it does a key decapsulation
for the specified recipient and decrypts the provided ciphertext. See <code>setup::setup_reciever</code>
and <code>AeadCtxR::open</code> for more detail.</dd><dt><a class="fn" href="fn.single_shot_open_in_place_detached.html" title="fn hpke::single_shot_open_in_place_detached">single_<wbr>shot_<wbr>open_<wbr>in_<wbr>place_<wbr>detached</a></dt><dd>Does a <code>setup_receiver</code> and <code>AeadCtxR::open_in_place_detached</code> in one shot. That is, it does a
key decapsulation for the specified recipient and decrypts the provided ciphertext in place.
See <code>setup::setup_reciever</code> and <code>AeadCtxR::open_in_place_detached</code> for more detail.</dd><dt><a class="fn" href="fn.single_shot_seal.html" title="fn hpke::single_shot_seal">single_<wbr>shot_<wbr>seal</a></dt><dd>Does a <code>setup_sender</code> and <code>AeadCtxS::seal</code> in one shot. That is, it does a key encapsulation to
the specified recipient and encrypts the provided plaintext. See <code>setup::setup_sender</code> and
<code>AeadCtxS::seal</code> for more detail.</dd><dt><a class="fn" href="fn.single_shot_seal_in_place_detached.html" title="fn hpke::single_shot_seal_in_place_detached">single_<wbr>shot_<wbr>seal_<wbr>in_<wbr>place_<wbr>detached</a></dt><dd>Does a <code>setup_sender</code> and <code>AeadCtxS::seal_in_place_detached</code> in one shot. That is, it does a
key encapsulation to the specified recipient and encrypts the provided plaintext in place. See
<code>setup::setup_sender</code> and <code>AeadCtxS::seal_in_place_detached</code> for more detail.</dd></dl></section></div></main></body></html>